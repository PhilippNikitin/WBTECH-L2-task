package visitor

/*
	Реализовать паттерн «посетитель».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Visitor_pattern

Паттерн "Посетитель" (Visitor) является поведенческим паттерном проектирования, который позволяет добавлять новую
функциональность в сложные иерархии объектов без изменения самих объектов. Он достигает этого путем введения внешнего
компонента, называемого посетителем, который может "посещать" различные объекты и выполнять необходимые операции.

Плюсы паттерна "Посетитель":
1. Отделение операций от структуры объектов. Паттерн "Посетитель" позволяет добавлять новые операции без изменения
классов объектов, их внутренней структуры, что способствует соблюдению принципа открытости/закрытости.
2. Упрощение добавления новых операций. Новые операции добавляются путем создания нового класса посетителя,
что делает код более модульным и управляемым.
3. Централизация операций. Данный паттерн позволяет собрать все операции, относящиеся к одной задаче,
в одном месте, что облегчает поддержку и понимание кода.

Минусы паттерна "Посетитель":
1. Усложнение структуры кода. Паттерн "Посетитель" может привести к увеличению числа классов в программе,
что усложняет структуру и может сделать код менее читаемым.
2. Нарушение инкапсуляции. Посетитель требует, чтобы операции, которые он выполняет, были доступны
в публичном интерфейсе объектов, что может нарушить принцип инкапсуляции.
3. Трудность при добавлении новых классов. Если иерархия объектов часто меняется или расширяется новыми классами,
необходимо будет обновлять все существующие посетители, что может быть трудоемким.

Реальное применение паттерна "Посетитель" в практике:
1. Обработка документов и их элементов.
В текстовых или графических редакторах можно использовать паттерн "Посетитель" для реализации таких операций, как экспорт
в различные форматы файлов (например, PDF, HTML), подсчет количества элементов, выделение текста и т.д.
Посетитель позволяет добавлять новые операции над элементами документа без изменения самой структуры документа.
2. Анализ и обработка абстрактного синтаксического дерева (AST):
В компиляторах и интерпретаторах паттерн "Посетитель" может использоваться для обхода AST
и выполнения различных операций, таких как оптимизация кода, генерация промежуточного кода
или выполнение статического анализа. Каждый вид операции может быть реализован как отдельный класс-посетитель.
3. Обработка элементов GUI:
В приложениях с графическим интерфейсом пользователя (GUI) паттерн "Посетитель" может использоваться
для выполнения операций над различными элементами интерфейса, такими как кнопки, поля ввода, меню и т.д.
Например, можно реализовать операцию "перерисовать" для всех элементов интерфейса без изменения их самих классов.
4. Системы обработки данных:
В системах обработки больших данных или обработки событий паттерн "Посетитель" может применяться для выполнения
различных операций над элементами данных или событиями. Например, в системе учета данных можно использовать посетителя
для агрегации данных, генерации отчетов или выполнения статистического анализа.
5. Графические библиотеки и движки:
При разработке игр или графических приложений паттерн "Посетитель" может быть полезен для обхода и выполнения операций
над объектами сцены, такими как игровые объекты, частицы, свет и т.д. Это позволяет добавлять новые эффекты, взаимодействия
или расширять функциональность без изменения основной структуры объектов.
*/

/*
Практический пример применения паттерна "Посетитель" в контексте веб-разработки
*/

import "fmt"

// определяем интерфейс для элементов веб-страницы, которые могут быть посещены
type Element interface {
	Accept(visitor Visitor)
}

// определяем интерфейс посетителя
type Visitor interface {
	VisitParagraph(p *Paragraph)
	VisitImage(i *Image)
	VisitLink(l *Link)
}

// определяем структуры для различных элементов веб-страницы (параграфов, изображений и ссылок)
// и реализуем метод Accept для каждого из них

// Paragraph структура для параграфов
type Paragraph struct {
	Text string
}

func (p *Paragraph) Accept(visitor Visitor) {
	visitor.VisitParagraph(p)
}

// Image структура для изображений
type Image struct {
	URL string
}

func (i *Image) Accept(visitor Visitor) {
	visitor.VisitImage(i)
}

// Link структура для ссылок
type Link struct {
	URL  string
	Text string
}

func (l *Link) Accept(visitor Visitor) {
	visitor.VisitLink(l)
}

// создаем двух посетителей, которые будут выполнять различные операции над элементами веб-страницы:
// одного для рендеринга элементов в HTML (HTMLRenderer) и другого для подсчета статистики
// элементов (StatisticsCounter).

// HTMLRenderer
type HTMLRenderer struct{}

func (r *HTMLRenderer) VisitParagraph(p *Paragraph) {
	fmt.Printf("<p>%s</p>\n", p.Text)
}

func (r *HTMLRenderer) VisitImage(i *Image) {
	fmt.Printf("<img src=\"%s\" />\n", i.URL)
}

func (r *HTMLRenderer) VisitLink(l *Link) {
	fmt.Printf("<a href=\"%s\">%s</a>\n", l.URL, l.Text)
}

// StatisticsCounter
type StatisticsCounter struct {
	ParagraphCount int
	ImageCount     int
	LinkCount      int
}

func (c *StatisticsCounter) VisitParagraph(p *Paragraph) {
	c.ParagraphCount++
}

func (c *StatisticsCounter) VisitImage(i *Image) {
	c.ImageCount++
}

func (c *StatisticsCounter) VisitLink(l *Link) {
	c.LinkCount++
}

func (c *StatisticsCounter) Report() {
	fmt.Printf("Paragraphs: %d\n", c.ParagraphCount)
	fmt.Printf("Images: %d\n", c.ImageCount)
	fmt.Printf("Links: %d\n", c.LinkCount)
}

// создаем несколько элементов веб-страницы и применяем к ним посетителей
func main() {
	elements := []Element{
		&Paragraph{Text: "Hello, World!"},
		&Image{URL: "https://example.com/image.png"},
		&Link{URL: "https://example.com", Text: "Example"},
	}

	htmlRenderer := &HTMLRenderer{}
	statisticsCounter := &StatisticsCounter{}

	for _, element := range elements {
		element.Accept(htmlRenderer)
		element.Accept(statisticsCounter)
	}

	statisticsCounter.Report()
}
