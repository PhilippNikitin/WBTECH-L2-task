package strategy

/*
	Реализовать паттерн «стратегия».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Strategy_pattern

Паттерн "Стратегия" (Strategy) — это один из поведенческих паттернов проектирования, который позволяет изменять поведение
объекта в зависимости от его состояния или окружения. Он помогает определить семейство алгоритмов, инкапсулировать каждый
из них и делать их взаимозаменяемыми. Этот паттерн часто используется для того, чтобы сделать код более гибким и легко
расширяемым.

Применимость паттерна "Стратегия":
1. Когда есть несколько вариантов алгоритмов или поведения: например, если у вас есть несколько алгоритмов сортировки,
которые могут быть применены к одному и тому же набору данных.
2. Когда нужно избежать использования множества условных операторов: вместо использования сложных цепочек if-else или
switch-case для выбора алгоритма, использование паттерна "Стратегия" может сделать код чище и легче для понимания.
3. Когда нужно разделить реализацию алгоритмов от их использования: паттерн "Стратегия" позволяет изменить алгоритм без
изменения кода, который его использует.
4. Когда алгоритмы могут меняться независимо: Например, если разные части системы могут требовать разных алгоритмов или
стратегий, которые могут меняться без изменения других частей системы.

Плюсы паттерна "Стратегия":
1. Упрощение кода: код становится более понятным и поддерживаемым, так как он разделяется на независимые стратегии.
2. Легкость добавления новых алгоритмов: новые стратегии можно добавлять без изменения существующего кода.
3. Повторное использование: стратегии могут быть повторно использованы в разных частях программы.
4. Упрощение тестирования: каждая стратегия может тестироваться отдельно, что упрощает отладку и проверку.

Минусы паттерна "Стратегия":
1. Увеличение количества классов: "Стратегия" может привести к значительному увеличению количества классов, особенно
если количество алгоритмов велико.
2. Увеличение количества кода: все стратегии должны реализовывать общий интерфейс, что может привести к увеличению размера программы,
в случае наличия большого количества методов у интерфейса.
3. Изменение кода клиента: если объект клиента должен знать о стратегиях и управлять ими, это может увеличить сложность кода клиента.
*/

/*
Пример реализации паттерна "Стратегия" для различных стратегий обработки запросов в веб-сервере:
*/

import "fmt"

// RequestHandler определяет стратегию обработки запросов
type RequestHandler interface {
	Handle(request string) string
}

// JSONHandler обрабатывает запросы в формате JSON
type JSONHandler struct{}

func (j *JSONHandler) Handle(request string) string {
	return fmt.Sprintf("Handling JSON request: %s", request)
}

// XMLHandler обрабатывает запросы в формате XML
type XMLHandler struct{}

func (x *XMLHandler) Handle(request string) string {
	return fmt.Sprintf("Handling XML request: %s", request)
}

// RequestProcessor использует стратегию обработки запросов
type RequestProcessor struct {
	handler RequestHandler
}

// SetHandler позволяет устанавливать стратегию обработки запросов
func (rp *RequestProcessor) SetHandler(handler RequestHandler) {
	rp.handler = handler
}

// ProcessRequest обрабатывает запрос с помощью установленной стратегии
func (rp *RequestProcessor) ProcessRequest(request string) {
	result := rp.handler.Handle(request)
	fmt.Println(result)
}

func main() {
	// Создаем экземпляр RequestProcessor
	processor := &RequestProcessor{}

	// Устанавливаем стратегию для обработки JSON запросов
	jsonHandler := &JSONHandler{}
	processor.SetHandler(jsonHandler)
	processor.ProcessRequest("Get user data")

	// Меняем стратегию на обработку XML запросов
	xmlHandler := &XMLHandler{}
	processor.SetHandler(xmlHandler)
	processor.ProcessRequest("Get user profile")
}
