package factory_method

/*
	Реализовать паттерн «фабричный метод».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Factory_method_pattern

Фабричный метод (Factory Method) — это порождающий паттерн проектирования, который предоставляет интерфейс для создания
объектов в суперклассе, но позволяет подклассам изменять тип создаваемых объектов. Этот паттерн используется, когда
заранее неизвестно, объекты каких классов понадобятся, или для того, чтобы делегировать создание объектов подклассам.

Применение паттерна «фабричный метод»:
1. Рефакторинг кода для удобства расширения: Фабричный метод часто используется в больших проектах для разделения процесса
создания объектов и их использования. Это позволяет легко добавлять новые виды объектов, не изменяя существующий код.
2. Упрощение работы с большим количеством подклассов: Когда нужно работать с большим количеством классов,
которые имеют схожую структуру или поведение, фабричный метод помогает создать интерфейс для создания этих объектов.
3. Инкапсуляция создания сложных объектов: иногда процесс создания объекта может быть сложным, включающим
множество шагов и конфигураций. Фабричный метод позволяет скрыть этот процесс от клиента, предоставляя простой интерфейс для
создания объекта.

Плюсы паттерна «фабричный метод»:
1. Упрощение добавления новых продуктов: Можно легко добавлять новые классы продуктов, просто создав новые подклассы
и фабрики для их создания.
2. Поддержка принципа открытости/закрытости (OCP): Классы легко расширяются без изменения существующего кода.
3. Инкапсуляция логики создания: Сложная логика создания объектов скрывается за фабричным методом, упрощая код клиента.

Минусы паттерна «фабричный метод»:
1. Усложнение кода: введение фабричных методов может добавить дополнительный уровень абстракции и усложнить понимание и сопровождение
кода.
2. Необходимость создания подклассов: Для каждого нового типа продукта нужно создавать новый подкласс, что может привести к увеличению
количества классов в проекте.
3. Меньшая гибкость: В некоторых случаях использование фабричных методов может ограничить гибкость и требовать создания большого
количества подклассов и фабрик для удовлетворения различных требований.

Примеры практического применения паттерна «фабричный метод»:
1. Управление подключениями к базам данных. Когда приложение поддерживает несколько типов баз данных (например, SQL и NoSQL),
фабричный метод может помочь в создании правильного типа подключения в зависимости от конфигурации или условий выполнения.
2. Работа с различными типами сообщений. Если приложение взаимодействует с различными типами сообщений или событий (например,
через очереди сообщений, различные API или системы логирования), фабричный метод позволяет создавать объекты для обработки этих сообщений
в зависимости от их типа.
3. Создание различных типов API клиентов. бэкэнд взаимодействует с различными внешними API, вы можете использовать фабричный метод
для создания клиентов API в зависимости от используемого сервиса или типа запроса
*/

/*
Пример реализации паттерна "Фабричный метод" для разрешения ситуации, когда нам нужно создать объекты для разных типов подключения к базам
данных.
*/

import "fmt"

// определяем интерфейс для подключения к базе данных и конкретные реализации для MySQL и PostgreSQL
// DatabaseConnection - интерфейс для подключения к базе данных
type DatabaseConnection interface {
	Connect() string
}

// MySQLConnection - конкретная реализация интерфейса DatabaseConnection для MySQL
type MySQLConnection struct{}

func (c *MySQLConnection) Connect() string {
	return "Connected to MySQL database"
}

// PostgreSQLConnection - конкретная реализация интерфейса DatabaseConnection для PostgreSQL
type PostgreSQLConnection struct{}

func (c *PostgreSQLConnection) Connect() string {
	return "Connected to PostgreSQL database"
}

// Определяем интерфейс фабрики и конкретные фабрики для создания подключения к каждой базе данных
// ConnectionFactory - интерфейс фабрики для создания подключения
type ConnectionFactory interface {
	CreateConnection() DatabaseConnection
}

// MySQLFactory - конкретная фабрика для MySQL
type MySQLFactory struct{}

func (f *MySQLFactory) CreateConnection() DatabaseConnection {
	return &MySQLConnection{}
}

// PostgreSQLFactory - конкретная фабрика для PostgreSQL
type PostgreSQLFactory struct{}

func (f *PostgreSQLFactory) CreateConnection() DatabaseConnection {
	return &PostgreSQLConnection{}
}

// создание подключения к нужной базе данных
func main() {
	var factory ConnectionFactory

	// Выбор фабрики на основе каких-то условий (например, конфигурации)
	factory = &MySQLFactory{}
	mysqlConnection := factory.CreateConnection()
	fmt.Println(mysqlConnection.Connect())

	factory = &PostgreSQLFactory{}
	postgresConnection := factory.CreateConnection()
	fmt.Println(postgresConnection.Connect())
}
