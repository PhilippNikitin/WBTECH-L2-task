package state

/*
	Реализовать паттерн «состояние».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/State_pattern

Применимость паттерна "Состояние":
Паттерн "Состояние" — поведенческий паттерн проектирования, который позволяет объекту изменять свое поведение
в зависимости от его внутреннего состояния. Поведение объекта меняется так, как если бы объект изменил свой класс.
Паттерн "Состояние" позволяет избежать использования множества условных операторов для реализации различных состояний объекта
и упрощает добавление новых состояний.
1. Когда объект должен изменять свое поведение в зависимости от внутреннего состояния.
Например, объекты в разных состояниях должны выполнять разные действия.
2. Когда внутреннее состояние объекта часто меняется. Это особенно актуально для таких состояний, как состояния процесса
или этапы жизненного цикла.
3. Когда код содержит сложную логику перехода между состояниями. Паттерн помогает организовать и упростить
переходы между состояниями, а также сделать код более читаемым и поддерживаемым.
4. Когда необходимо избежать использования многочисленных условных операторов. Паттерн помогает заменить цепочки
if-else или switch-case, которые могут усложнять понимание и сопровождение кода.

Плюсы паттерна "Состояние":
1. Упрощение кода: паттерн помогает организовать код, избавляя от необходимости использовать сложные условные операторы для определения
текущего состояния и соответствующего поведения.
2. Повышение расширяемости: добавление новых состояний становится проще, так как каждое состояние реализуется в отдельном классе.
Это позволяет легко расширять функциональность.
3. Изоляция логики состояний: логика каждого состояния инкапсулирована в своем собственном классе, что облегчает управление и тестирование.
4. Упрощение изменений: изменения в поведении объекта можно внести в конкретные классы состояний, не затрагивая остальной код.

Минусы паттерна "Состояние":
1. Увеличение числа классов: каждое отдельное состояние требует создания нового класса, что может привести к увеличению числа классов
в проекте.
2. Риск нарушения принципа единственной ответственности: каждый класс состояния может содержать логику для различных аспектов поведения
объекта, что может привести к нарушению принципа единственной ответственности.
3. Сложность понимания: в некоторых случаях организация переходов между состояниями может стать сложной и трудной для понимания,
особенно если количество состояний велико.

Реальное применение паттерна "Состояние":
1. Обработка запросов и сессий. Например, система обработки платежей может находиться в различных состояниях:
"Ожидание платежа", "Платеж обработан", "Ошибка обработки", и т.д. Паттерн "Состояние" позволяет организовать код таким образом,
чтобы обрабатывать переходы между этими состояниями и выполнять соответствующие действия.
2. Управление жизненным циклом заказов. Заказы могут находиться в различных состояниях: "Создан", "Подтвержден", "Отправлен", и т.д.
Паттерн "Состояние" помогает организовать переходы между этими состояниями и выполнить соответствующие действия, такие как уведомление клиентов,
обновление базы данных и т.д.
3. Аутентификация и авторизация. В системах аутентификации и авторизации пользователь может находиться в разных состояниях: "Неавторизован",
"Авторизован", "Заблокирован", "Ожидание подтверждения". Паттерн "Состояние" позволяет управлять логикой доступа и действиями в зависимости от состояния
пользователя.
*/

/*
Пример практического применения паттерна "Состояния" для управления жизненным циклом заказов
*/

import "fmt"

// OrderState определяет интерфейс для различных состояний заказа
type OrderState interface {
	ProcessOrder()
}

// Context для управления состоянием заказа
type OrderContext struct {
	state OrderState
}

func (o *OrderContext) SetState(state OrderState) {
	o.state = state
}

func (o *OrderContext) ProcessOrder() {
	o.state.ProcessOrder()
}

// Конкретные состояния заказа
type CreatedState struct{}

func (c *CreatedState) ProcessOrder() {
	fmt.Println("Order has been created.")
}

type ShippedState struct{}

func (s *ShippedState) ProcessOrder() {
	fmt.Println("Order has been shipped.")
}

type DeliveredState struct{}

func (d *DeliveredState) ProcessOrder() {
	fmt.Println("Order has been delivered.")
}

type CancelledState struct{}

func (c *CancelledState) ProcessOrder() {
	fmt.Println("Order has been cancelled.")
}

func main() {
	order := &OrderContext{}

	order.SetState(&CreatedState{})
	order.ProcessOrder()

	order.SetState(&ShippedState{})
	order.ProcessOrder()

	order.SetState(&DeliveredState{})
	order.ProcessOrder()
}
